# LLM-First 架构原则（核心规则）

## 核心理念

**代码不写任何规则逻辑，一切由系统提示词驱动 LLM 语义判断。**

## 绝对禁止

| 禁止行为 | 正确做法 |
|---------|---------|
| 在代码中写评分策略 | 规则在提示词中用自然语言描述 |
| 在代码中写硬编码阈值 | LLM 直接输出判断结果 |
| 在代码中写 if/else 决策规则 | 提示词定义判断标准，LLM 推理 |
| 创建 XxxScorer、XxxCalculator 类 | 删除，完全依赖 LLM 输出 |
| 代码中定义 THRESHOLD、WEIGHT 常量 | 不需要，LLM 理解自然语言规则 |

## 架构模式

```
┌─────────────────────────────────────────────────────────────┐
│  instances/xxx/prompt.md                                    │
│  ├── 自然语言描述所有规则                                     │
│  ├── 定义什么是 simple/medium/complex                        │
│  ├── 定义什么场景需要多智能体                                  │
│  └── 场景特定的业务规则                                       │
└──────────────────────────┬──────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────────┐
│  LLM 语义理解 + 深度推理                                      │
│  └── 输出结构化判断结果（intent.complexity, needs_multi_agent）│
└──────────────────────────┬───────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────────┐
│  代码只传递 LLM 输出，不做任何判断                             │
│  ├── 直接使用 intent.complexity                               │
│  ├── 直接使用 intent.needs_multi_agent                        │
│  └── 不加工、不校验、不覆盖                                    │
└──────────────────────────────────────────────────────────────┘
```

## 核心优势

1. **场景通用性**：换场景只需修改提示词，代码无需变动
2. **规则灵活性**：自然语言描述规则，比代码更容易理解和修改
3. **维护简单**：运营人员可以直接修改提示词，不需要开发介入
4. **无硬编码**：不存在"不知道具体评分规则"的问题

## 代码示例

### ❌ 错误：代码写规则

```python
# 绝对禁止！
class ComplexityScorer:
    SIMPLE_THRESHOLD = 3.0
    MEDIUM_THRESHOLD = 5.0
    
    def score(self, intent):
        if intent.task_type == TaskType.CODE_DEVELOPMENT:
            return 5.0  # 硬编码
        # ...

# 绝对禁止！
if complexity_score > THRESHOLD:
    use_multi_agent = True
```

### ✅ 正确：代码只传递

```python
# 直接使用 LLM 输出，不做任何判断
def route(self, intent):
    return RoutingDecision(
        agent_type="multi" if intent.needs_multi_agent else "single",
        intent=intent,
    )
```

## 规则所在位置

| 规则类型 | 位置 |
|---------|------|
| 复杂度判断规则 | `instances/xxx/prompt.md` 或 `prompts/intent_recognition_prompt.py` |
| 多智能体触发规则 | 提示词中用自然语言描述 |
| 任务类型定义 | 提示词中用自然语言描述 |
| 业务特定规则 | `instances/xxx/prompt.md`（不同场景不同规则） |

## Instance 提示词模板（重要）

### 模板结构

每个 `instances/{name}/prompt.md` 必须包含：

```markdown
## LLM 判断规则（核心）

### 任务复杂度判断
- SIMPLE：...（场景特定的简单任务定义）
- MEDIUM：...（场景特定的中等任务定义）
- COMPLEX：...（场景特定的复杂任务定义）

### 多智能体触发条件
- 什么情况需要多智能体协作
- 什么情况不需要

### 规划触发条件
- 什么情况需要 plan_todo
- 什么情况不需要

### 持久化需求
- 什么信息需要跨会话记忆
```

### 设计要点

| 原则 | 说明 |
|------|------|
| **场景特定** | 不同业务有不同的复杂度标准 |
| **自然语言** | 用人话描述，不用技术术语 |
| **完整覆盖** | 覆盖所有 LLM 需要判断的字段 |
| **有默认值** | 框架提供默认规则，运营可覆盖 |

### 示例：本地助手 vs 数据分析

```markdown
# 本地助手的 SIMPLE
- 打开应用、发消息
- 查天气、时间

# 数据分析的 SIMPLE
- 查看数据概览
- 简单统计（求和、平均）
```

**不同场景，不同规则，代码无需变动。**

## 检查清单

修改代码前检查：
- [ ] 是否在写 if/else 判断规则？→ 移到提示词
- [ ] 是否在定义阈值常量？→ 删除，用自然语言
- [ ] 是否在创建 Scorer/Calculator？→ 删除
- [ ] 换个场景，代码需要改吗？→ 如果需要，说明架构有问题
- [ ] 新增的判断逻辑是否在 prompt.md 模板中有引导？→ 如果没有，更新模板
