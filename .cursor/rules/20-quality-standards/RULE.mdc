---
description: "交付质量标准（强制）：高标准严格要求，不放过任何细节"
alwaysApply: true
---

# 交付质量标准（强制）

## 核心原则

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                                                                                 │
│  每一次交付 = 完整的闭环，不是"差不多就行"                                     │
│                                                                                 │
│  写代码 → 验证能跑 → 验证数据一致 → 验证上下游联动 → 验证边界情况               │
│                                                                                 │
│  偷懒 = 留坑 = 后面花 10 倍时间修                                               │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

---

## 一、禁止偷懒行为（强制）

### ❌ 禁止：只改了一处，没查上下游

```
# ❌ 改了数据结构，没查谁在读这个结构
# ❌ 改了配置格式，没查谁在解析这个配置
# ❌ 加了新模块，没加到所有需要感知它的地方

# ✅ 每次改动必须 grep 所有引用点，逐一确认
```

### ❌ 禁止：改完不验证

```
# ❌ "应该没问题" — 不跑一下怎么知道？
# ❌ "这个改动很小" — 越小越容易忽略副作用
# ❌ "之后再测" — 之后就忘了

# ✅ 改完立即验证（lint / 脚本 / 手动跑一遍）
```

### ❌ 禁止：分类/分组/配置不完整

```
# ❌ 加了新 skill 没加到 skill_groups → 意图过滤时永远不可见
# ❌ 加了新 API 没加到路由注册 → 前端调不到
# ❌ 加了新配置项没加到模板 → 新实例缺配置启动失败

# ✅ 新增任何实体，必须检查所有注册/分组/索引是否同步
```

### ❌ 禁止：status/状态字段不验证

```
# ❌ 标了 status: ready 但依赖根本没装
# ❌ 标了 dependency_level: builtin 但实际需要外部工具

# ✅ 每个 status 必须通过实际检测确认，不凭感觉标
```

---

## 二、变更完整性检查清单（强制）

每次代码变更后，**必须逐项检查**：

### 数据一致性

- [ ] 新增的实体（skill/group/config/route）是否在所有注册点都添加了？
- [ ] 修改了数据结构/格式后，所有读取方是否适配了新格式？
- [ ] 配置模板（`_template/`）是否同步更新？
- [ ] 枚举/常量修改后，所有 switch/if 分支是否覆盖？

### 上下游联动

- [ ] 改了生产方（writer），消费方（reader）是否还能正确读取？
- [ ] 改了接口签名，所有调用方是否更新了参数？
- [ ] 删除了导出，所有 import 是否清理了？
- [ ] 改了缓存格式，旧缓存是否兼容或需要清理？

### 运行时验证

- [ ] lint 无报错？
- [ ] 改动涉及的最短路径能跑通？（不需要全量 E2E，但至少 smoke test）
- [ ] 涉及状态/依赖检测的，实际运行检测结果是否符合预期？

---

## 三、分组/注册/索引同步规则（强制）

当新增任何「可被索引的实体」时，必须同步更新所有索引点：

| 新增实体 | 必须同步的位置 |
|---|---|
| 新 Skill | config/skills.yaml 清单 + skill_groups 分组 + skill_registry.yaml |
| 新 Skill Group | config/skills.yaml skill_groups（description + skills）|
| 新 API 端点 | routers/ + main.py 路由注册 + 前端 API 层 |
| 新配置项 | config.yaml + _template/config.yaml + 解析代码 |
| 新 Injector | injectors/ + orchestrator 注册 |
| 新 Tool | tool 定义 + ToolLoader 注册 + skills.yaml |

**检查方法**：`grep -r "新实体名" .` 确认所有引用点。

---

## 四、测试验证标准（强制）

### 改了就要验证，没有例外

| 变更类型 | 最低验证要求 |
|---|---|
| 纯配置/YAML 修改 | YAML 语法校验 + 加载代码能解析不报错 |
| Python 模块新增/修改 | lint 无报错 + import 不报错 |
| 数据流改动（injector/loader） | 写验证脚本跑一遍关键路径 |
| 接口签名变更 | grep 所有调用方，逐一确认参数匹配 |
| 前端组件 | 启动 dev server 看页面不白屏 |
| E2E 相关改动 | 跑对应的 E2E case |

### 验证脚本优于"我看了一下代码应该没问题"

```python
# ✅ 正确：写个 3 行验证脚本
import yaml
config = yaml.safe_load(open("instances/xiaodazi/config/skills.yaml"))
groups = config["skill_groups"]
for name, group in groups.items():
    assert "description" in group and "skills" in group, f"{name} 格式错误"
print(f"✅ {len(groups)} 个分组格式正确")

# ❌ 错误："我检查了 YAML 文件，格式应该没问题"
```

---

## 五、交付前自检流程

每次交付前（回复用户前），快速自检：

1. **完整性**：我是不是遗漏了某个注册点/同步点？
2. **一致性**：多处数据是否对得上？（名称、格式、枚举值）
3. **可运行**：改动能跑起来吗？（至少 lint + import 不报错）
4. **边界情况**：空值、缺失字段、旧格式兼容是否处理了？
5. **用户视角**：站在用户（包括小白用户）角度，这个改动的体验是否完整？

---

## 六、"以点带面"原则（强制）

发现一个 bug 时，不要只修这一个点。必须追问：

1. **同类问题**：其他模块有没有一样的模式？（grep 搜同类代码）
2. **根因**：为什么会出这个 bug？是架构问题还是疏忽？
3. **防御**：怎么防止这类 bug 再出现？（加校验？加 lint 规则？加文档？）

```
❌ "修了这个 bug" → 完事了
✅ "修了这个 bug" → 搜了同类 → 发现 3 处同样问题 → 一起修 → 加了校验防止复发
```
